1. the difference between internal and external linkage using examples from your code
 - I used internal linkage for counting how many times the helper function called in my code. For example, I have used static in count = 0; in my helper function std::ostream& operator<<(std::ostream& os, const String& obj). internal linkage is an invisible entity outside but visible to other scopes in the translation unit, while I used external linkage for making g_maxSize. For instance, I declare extern unsigned int g_maxSize; in header file and define unsigned int g_maxSize = 3; in CPP file. The external linkage is an entity which is declared in another translation unit scope.
2. what are `static` variables and how were they useful in this workshop.
 - The advantage of a static variable is globally available and Unlike regional variables within a function, static values do not disappear. Therefore, by using a static variable, a variable can be declared when using the helper function in the workshop. Even if a variable is used again, the value of the variable cannot be initialized, so it can be used cumulatively at the existing value
3. the changes that you made in upgrading your `String` class.
 - In the workshop home part, I used the member variable of an object as a char pointer for using the dynamic allocated memory. Dynamic allocation memory allows you to resize the member variables of an object to match the size of the string of parameters.
4. I have learned about external and internal linkage. I was confused between them to finish my workshop because I have never used linkage before. The external linkage "extern" is hard to understand, so I studied a lot and I understood finally. Also, I have studied about command-line arguments and I used them the first time as well. I can compare between int argc and char* argv[] now. I have learned main() function with a parameter, not void, in interface with the operating system.
